1. Basic Structure of a Java Program

    The main method is the entry point.

    public class name must match the filename (Running_java.java).

    A file must have a single public class only which will act as the entry point.

    Compilation: javac Running_java.java

    Running: java Running_java (no .class or .java in the command)

2. Java Rule: You can define multiple classes in one .java file, butâ€¦
    # Only one of them can be declared as public
    # The file must be named after that public class
    # All classes will be compiled, but only those with main() can be run directly

2. File Name vs Class Name

    Situation	                    Rule
    Class is public	                File name must match the class name
    Class is not public	            File name can be anything
    Multiple classes in one file	Only one can be public
    File has no main method	        Can compile, but cannot run directly


3. Can I Run Any Class Separately?

    Yes, if the class has a main() method.

4. Packages and Folders

    package Basics;
    File must be inside Basics/ folder
    Must be compiled and run from the parent folder 

5. Compilation  needed or not 

    Case	                    Compile Needed?	                Command
    Java 8 or below	            Yes	                            javac A.java then java A
    Java 11+ (no package)	    No	                            java A.java
    Java 11+ with package	    Yes	                            javac pkg/A.java, java pkg.A


6. How to Handle Same Class Names in Java (e.g., A.java and A.java)
    1. You cannot have two classes with the same name in the same package
        If both File1.java and File2.java define a class A inside the same package (e.g., package Basics;), then:
            Both will compile.
            The second compilation will overwrite the previous A.class.

    2. Use different packages to avoid conflict
        Place each A.java file in its own package (namespace), like:
        package Basics.one;
        package Basics.two;


ABSTRACT CLASSES -: 
-------------------

    1. Abstract Class
        - Declared with the 'abstract' keyword.
        - Cannot be instantiated directly.
        - Serves as a base class for other classes.
        - Can contain:
            * Abstract methods (no body).
            * Concrete methods (with body).
            * Fields, constructors, static methods.
        - May include final methods that cannot be overridden.

    2. Abstract Methods
        - Declared using the 'abstract' keyword and end with a semicolon.
        - Have no implementation (no body) in the abstract class.
        - Must be implemented by the first concrete subclass.
        - Example:
            abstract void draw();

    3. Rules
        - If a class has even one abstract method, the class must be abstract.
        - An abstract class may have zero abstract methods (still valid).
        - A non-abstract subclass must override all abstract methods of its parent.
        - If not, the subclass must also be declared abstract.

    4. Overriding
        - Abstract methods: Must be overridden by concrete subclasses.
        - Concrete methods: Can optionally be overridden in subclasses.
        - Rules of overriding apply (same signature, covariant return, non-restrictive access modifier).

    5. Abstract Class vs Interface
        - Abstract Class:
            * Can have both abstract and concrete methods.
            * Can have fields (instance variables).
            * Single inheritance only (a class can extend one abstract class).
        - Interface:
            * Methods are abstract by default (until Java 8+ added default/static methods).
            * Cannot have instance fields (only constants).
            * Multiple inheritance supported (a class can implement multiple interfaces).

    6. Use Cases of Abstract Classes
        - When you want to share code among related classes.
        - When you want to define a template and enforce subclasses to implement specific behavior.
        - When some methods should have a common implementation, while others should be left for subclasses.

    7. Example
        abstract class Animal {
            abstract void makeSound(); // abstract method
            void eat() {               // concrete method
                System.out.println("Eating...");
            }
        }

        class Dog extends Animal {
            @Override
            void makeSound() {
                System.out.println("Bark");
            }
        }

    8. Key Takeaways
        - Abstract methods: like interface methods, force implementation in subclasses.
        - Abstract class: mix of template + partial implementation.
        - Non-abstract subclasses MUST override abstract methods, but can choose to override concrete methods.
